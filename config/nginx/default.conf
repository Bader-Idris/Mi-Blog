server {
  listen 80;
  # server_name example.com;

  server_tokens off;
  # this ðŸ‘‡ removes server headers, but it causes nginx to get killed!
  # more_clear_headers Server;
  # add_header Server "BaderIdris.com";
  add_header Content-Security-Policy "default-src 'self'; style-src 'self'; script-src 'self'; frame-src 'self' https://www.youtube.com";

  # this is to send files without caching, or use max-age=3600 using seconds! so this is an hour
  add_header Cache-Control max-age=00;
  # add_header Cache-Control "no-cache"; ðŸ”´ðŸ”´ðŸ”´ðŸ”´ don't stay as 00

  location /public {
    alias /usr/share/nginx/html/public;
    # bito says these two serves offline static files:ðŸ”´
    expires 1h;
    add_header Cache-Control "public, must-revalidate, proxy-revalidate";
  }
  location /views {
    alias /usr/share/nginx/html/views;
    # bito says these two serves offline static files:ðŸ”´
    expires 1h;
    add_header Cache-Control "public, must-revalidate, proxy-revalidate";
  }
  location / {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_set_header X-Nginx-Proxy true;
    proxy_pass http://my-blog:3000;
    proxy_redirect off;
  }
  location /api {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_set_header X-Nginx-Proxy true;
    proxy_pass http://my-blog:3000;
    proxy_redirect off;
  }
  error_page 404 /404.html;
  location = /404.html {
    alias /etc/nginx/conf.d/404.html;
    internal;
  }
  # events {}
}
# to reload nginx if it didn't do this!
#  docker exec -it <container_id_or_name> nginx -s reload
#  docker exec -it my-blog-nginx nginx -s reload


# 1. Remove Server Tokens:
#    - Uncomment the `more_clear_headers` directive and add the `Server` header to remove server tokens. This helps to hide information about the server software being used.
# 2. Content Security Policy (CSP):
#    - Review and update the `Content-Security-Policy` directive to restrict the sources from which certain types of content can be loaded. For example, you can specify allowed sources for stylesheets, scripts, images, fonts, etc.
#    - Avoid using `'unsafe-inline'` and `'unsafe-eval'` unless absolutely necessary. Instead, move styles and scripts to external files and specify their sources in the CSP header.
# 3. HTTP Headers:
#    - Consider adding other security-related headers, such as `X-Content-Type-Options`, `X-Frame-Options`, and `Referrer-Policy`, to enhance protection against certain types of attacks. You can add these headers using the `add_header` directive.
# 4. Secure Transport:
#    - If your application supports HTTPS, ensure that you redirect HTTP traffic to HTTPS by adding a separate server block with a redirect rule.
# 5. Access Control:
#    - Implement access control mechanisms, such as IP whitelisting or authentication, to restrict access to sensitive areas of your application or administrative interfaces.
# 6. Rate Limiting:
#    - Implement rate limiting to prevent abuse or brute-force attacks. This can be achieved using the `ngx_http_limit_req_module` or third-party modules like `ngx_http_limit_req_zone`.
# 7. Logging and Monitoring:
#    - Enable logging and monitoring to detect and respond to potential security incidents. Monitor access logs, error logs, and other relevant logs to identify suspicious activities.
# Remember, security is a continuous process, and it's important to regularly review and update your security measures as new threats emerge. Consider consulting with a security professional or conducting a security audit to ensure your application is adequately protected.